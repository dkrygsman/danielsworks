---
title: PIC32 Uart Driver
description: ECE 121 Project
date: 2023-04-14
published: true
---

### Introduction 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For UC Santa Cruz's electrical engineering program, a concentration of communication signals and systems, or electronics and optics must be chosen and a respective design elective based of the concentration. I chose electronics and optics with the design elective ECE 121, Microcontroller System Design. The final project for this course was to create a uart driver for the PIC32 microcontroller. This involved understanding the hardware architecture of the PIC32 and understanding how to interpret the family reference manual to design a uart driver that interfaces properly to the hardware, parses the data into packages, and returns the package based on its message ID. This is done on the ChipKit uno32 development board by diligent, coded and debugged using MPLab X IDE. 


### Block Diagram 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The project can be broken up into two distinct layers, the physical layer, and the application layer. The physical layer is referenced in the below block diagram figure and only consists of the uart bridge chip and is uart rx and tx registers (hardware components), two instances of a circular buffer struct (rx and tx), and the Getchar and Putchar functions for adding or taking from the rx/tx buffers. As for the application layer, this consists of a serial protocol parser function that verifies and creates packages from the incomming characters (head, length, payload, tail, checksum, end). This is then passed to the application which based on various ID's remakes the package and sendings it back to the physical layer to be transmitted back out of the Uno32 development board. Without the special ID"s spesified by the assignment the uart driver application layer just sends the packet as is back to the transmit side, if the package starts with the Debug ID, then it returns the date and time. If the package starts with the Ping ID then the ID is changed to Pong and the rest of the message (payload) is converted from big endian to little endian and returned. The last two ID cases are the Set and Get ID's which based off the rest of the message (payload) sets or gets the status of lit LEDS on the board. 

<p align="center">
    ![uart block diagram](uart_block.png)
    uart driver block diagram
</p>


```js {4} showLineNumbers
void __ISR(_UART_1_VECTOR)IntUart1Handler(void)
{
    int checker = 0;
    if(IFS0bits.U1RXIF)                                     //RX block
    {
        IFS0bits.U1RXIF = 0;                //URXDA is rx buffer sweet stop
        while(U1STAbits.URXDA && !is_buff_full(&rx_buffer))     //has room and data and buffer has room
        {
            add_to_buff(&rx_buffer, U1RXREG);               //add rxREG contents to rx_buff
            //LATE = 0b00000001;
        }
       
    }
    if(IFS0bits.U1TXIF)                         //TX block
    {
        IFS0bits.U1TXIF = 0;
        if(tx_busy)                             //if busy do nothing
        {
            //tx_collision = 1;
            //LATE = 0b00000010;
            //tx_busy = 0;
        }
        else                                                            
        {
            while (!is_buff_empty(&tx_buffer) && !U1STAbits.UTXBF)      //if not busy check if tx_buff has data and TX is not full
            {                   //UTXBF is 1 when TX is full
            
                unsigned char val;
                val = take_from_buff(&tx_buffer);           //print next char from tx_buffer
                U1TXREG = val;
                //LATE = 0b00000100;
                //tx_busy = 0;
            } 
            
          
        }
    
    }
    //tx_busy = 0;
    IFS0bits.U1TXIF = 0;                            //lower flag for special cases such as first flag raise
}
```

### Physical layer 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the





