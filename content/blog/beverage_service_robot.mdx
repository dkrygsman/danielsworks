---
title: Beverage Service Robot 
description: UCSC Capstone 2024 project
date: 2024-06-14
published: true
---
 
 # Introduction 

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UCSC's Electrical or Robotic Engineering B.S. degrees need to complete a senior exit reqirememt either a thesis or a capstone project. Without already being involved in a research lab and not having a topic to write a thesis about, the capstone project is the more common option. The capstone series consists of three quarters so en entire school year, not counting the summer quarter. The format of the series involves the first quarter being for research and understanding the appropriate ways to conduct standardized engineering, settling on a project, and assembling a team, while the other two quarters are for prototyping, testing, and presenting. Royce Shoi, Gonzalo Tiscarero, Isabella Almarez, and myself made up the beverage service robot team and our goal was to develope a low cost autonomously navigating robot for resturaunt beverage service. The break up of this project was Royce taking responsibility of the mechanical role, building the chassis and bot shell, Gonzalo responsible of power, such as desgining a power regulator and overall system for our needs, Isabella in responsible for electrical, such as testing and interfacing sensors, and myself responsible for software. For the sake of relivance, I will only be discussing my specific work for the project and only explain their work for context of my role.

 ### Software Archietecture 

 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Based off the project goals which will heavily require mapping and navigating in complex and changing envirements, we chose to use ROS2. We are running an onboard Raspberry Pi, and offboard laptop. We used the newest distribution at the time, ROS2 Iron, running on Ubuntu 22.04 jammy. ROS is appealing to projects like ours because it splits a complex robot up into "nodes". These nodes add a level of abstraction to the robot as a whole, making the information not needed for other nodes invisible and only publishes the information that is. The nodes in question can be split up into three groups, sensor nodes, actuator nodes, and software nodes. The sensor nodes are made up of a 2d spinning lidar node which configures with the A1 RPLidar, a 2d spinning lidar made by SlamTech, a node that configures with the OAK-D-Lite distance camera. The actuator node consists of a single differential motor control node, which utilizes the ROS control framework, and the software nodes consist of nodes running visualization via ROS2's RVIZ, mapping, navigation, and localization via ROS2's Slam Toolbox. At the start of this project, we underestimated the learning curve needed to work with ROS2 and because of this sevearly underestimated the size of my specific role, software. 

### URDF 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The ROS archetecture uses a URDF or robot description file to tie all sensing and moving parts of the robot together and all bodies of the robot for mapping. This URDF file is made up of multiple xlm files in the form of macros. This is first done by creating the shape of the bot based on measurements given by Royce who designed the physical bot, because the bot was shaped as a tapered rectangle and ROS only provides shapes for rectangles, cylinders, and spheres this became a intensive process with precise measurements to create a body that matches our bot. ROS allows for importing STL files to give a exact shape which is something that can be utilized in the future or on other robotic projects. The moving bodies such as drive wheels and caster wheel are set as non-fixed bodies meaning they move. All bodies of the bot also have their respective moments of interia, resistance, weight which add to map to real world accuracy when testing. Bodies are also made for the lidar and camera also with respective "frames" which give the system information on where the origin of sensor data lies. Below are images for URDF file visualized and actual bot. 

### ROS2 Control

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;By far the largest part of my role of the project was interfacing the motors with the system. The ROS standard for interfacing motors is setting up a ROS Control node which sets all system read and write as state and command interfaces instead of using topics and actions. This is to decrease latency. Another issue that came up was the use of an seperate microcontroller to conduct all low level computation while the Pi only controls the command to each wheel and the position and velocity of each wheel. This follows the trend of adding levels of abstraction to the system. The offboard microcontroller used is an Arduino Nano running a differential drive controller code provided by a bay area robotics club, Homebrew Robotics Club.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The ROS control node is built off the supplied demos from the ROS Control, but then changed to work with the specific motor controller microcontrollers code. This entailes when and what data must be passsed via the serial connection which is written in C++ and utilizes the libserial library. Our bot uses two PID controlled motors. We chose to work use the GoBilda's Yellow Jacket Planetary motors with encoders because of the speed, torque, and price specs. The classes used are config and comms for variables and functions within the ROS system code, while two objects, wheel_l and wheel_r, of the wheel class are used for the ROS to Arduino motor controller code. The heart of the ROS Control node is a C++ program, which runs through states, those states being on_init, export_state_interfaces, export_command_interfaces, on_activate, on_configure, read, write, on_cleanup, and on_deactivate. With all of this working our bot can accurately and quickly control   


 {/* <iframe width="560" height="315" src="https://www.youtube.com/embed/u3F0A-JTb20?si=F2U2-iHD55ZZtkCJ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen ></iframe> */}


